    MODULE OSMAIN
  
  ; void UTFT::LCD_Write_COM(char VL)  
  ; void UTFT::LCD_Write_DATA(char VH,char VL)
  ;void UTFT::LCD_Write_DATA(char VL)
  ;void UTFT::LCD_Write_COM_DATA(char com1,int dat1)


    ORG 0x4000 
    
    ;global vars FROM BBC BASIC
    ACCS   EQU 0x6000       ;STRING INPUT BUFFER
    ERRLIN EQU ACCS+0x2F4   ;
    RANDOM EQU ACCS+0x2F6   ;RANDOM SEED MUST BE NON ZERO 5 BYTES
    TOP    EQU ACCS+0x2DE   ;START OF BASIC PROGRAM
    PAGE   EQU ACCS+0x2DC   ;END OF BASIC PROGRAM
    OSVARS EQU 0x6300       ;OS VARIABLES IN RAM
    ESCAPE EQU 0x0DE4       ;ESCAPE ROUTINE ON BBC BASIC
    CRLF   EQU 0x088F       ;CRLF ROUTINE ON BBC BASIC
    EXTERR EQU 0x0712       ;EXTERR ROUTINE ON BBC BASIC
    
    CR  	 EQU 0DH
    LF		 EQU 0AH
    ES		 EQU 1BH    
    BS     EQU 08H
    ESC    EQU 1BH
    
    ;LOCAL CONSTS
    PORT_STM_IO 		EQU	0x00			; The IO port for serial terminal IO
    PORT_STM_FLAGS	EQU	0x07			; Flags		
    PORT_TAPE       EQU 0X20      ; SAVE/LOAD PORT 1 BYTE=0xDD 2ND BYTE=COMMAND 
    COMMD_SAVE      EQU 10
    COMMD_LOAD      EQU 20;
    
    
    LCD_RS EQU 04;  ;PORT TO CONTROL RS PIN
    LCD_CS EQU 05;  ;PORT TO CONTROL CS PIN
    LCD_WIDTH  EQU 799
    LCD_HEIGHT EQU 479
    FONT_WIDTH EQU 8
    FONT_HEIGHT EQU 10
   
    
    
      JP MYOS_CLRSCN
      JP MYOS_PUTIME
      JP MYOS_GETIME
      JP MYOS_PUTCSR
      JP MYOS_GETCSR
      JP MYOS_OSRDCH
      JP MYOS_PROMPT
      JP MYOS_OSWRCH
      JP MYOS_OSKEY
      JP MYOS_OSINIT
      JP MYOS_OSLINE2
      JP MYOS_OSCLI
      JP MYOS_OSBPUT 
      JP MYOS_OSBGET 
      JP MYOS_OSSTAT 
      JP MYOS_OSSHUT 
      JP MYOS_OSOPEN 
      JP MYOS_OSCALL 
      JP MYOS_OSSAVE 
      JP MYOS_OSLOAD 
      JP MYOS_GETPTR 
      JP MYOS_PUTPTR 
      JP MYOS_GETEXT 
      JP MYOS_RESET 
      JP MYOS_TRAP
      JP MYOS_LTRAP  
      JP MYOS_CLG
      JP MYOS_COLOUR
      JP MYOS_DRAW
      JP MYOS_ENVEL
      JP MYOS_GCOL
      JP MYOS_MODE
      JP MYOS_MOVE
      JP MYOS_PLOT
      JP MYOS_SOUND
      JP MYOS_ADVAL
      JP MYOS_POINT
      JP MYOS_GETIMS
      JP MYOS_PUTIMS    
      

      
      
TEST: JP LCD_TEST    
    
MYOS_CLRSCN:        ; CLRSCN: clears the screen.
           RET
MYOS_PUTIME:        ; PUTIME: set current time to DE:HL, in centiseconds.
		       RET
MYOS_GETIME:        ; GETIME: return current time in DE:HL, in centiseconds.
       		 LD DE, 0
 	  		   LD HL, 0
			     RET		       
MYOS_PUTCSR:		    ; PUTCSR: move to cursor to x=DE, y=HL
           RET
MYOS_GETCSR:		    ; GETCSR: return cursor position in x=DE, y=HL
           LD DE,0
			     LD HL,0
			     RET
KEYGET:		LD      B,80 ;SCREEN WIDTH IN CHARS	     
MYOS_OSRDCH:        ; OSRDCH: read a character in from the keyboard	
           ;IN A,(PORT_STM_IO)
        	 PUSH    HL
           SBC     HL,HL           ;HL=0
           CALL    MYOS_OSKEY
           POP     HL
           RET     C
           JR      MYOS_OSRDCH           
			     RET		
MYOS_OSWRCH:		    ; OSWRCH: write a character to the screen            
			     PUSH    AF
           PUSH    DE
           PUSH    HL
           LD      E,A
           CALL    ESCTEST
           CALL    EDPUT
           POP     HL
           POP     DE
           POP     AF
           RET
;
EDPUT:  LD      A,(FLAGS)
        BIT     3,A
        JR      Z,WRCH
        LD      A,E
        CP      ' '
        RET     C
        LD      HL,(EDPTR)
        LD      (HL),E
        INC     L
        RET     Z
        LD      (EDPTR),HL
        RET           
           
MYOS_PROMPT: 	      ; PROMPT: output the input prompt	
           LD E,'>'			     
WRCH:      LD A,E
           OUT (0),A      
           PUSH AF
           PUSH BC
           PUSH DE
					 PUSH HL
					 ;CALL LCD_REMOVECURSOR
           CALL LCD_PRINTCHAR
          ; CALL LCD_PRINTCURSOR
           POP HL
           POP DE
           POP BC
           POP AF
			     RET 
;
TOGGLE: LD      A,(FLAGS)
        XOR     00000100B
        LD      (FLAGS),A
        RET
;
;OSKEY - Read key with time-limit, test for ESCape.
;Main function is carried out in user patch.
;   Inputs: HL = time limit (centiseconds)
;  Outputs: Carry reset if time-out
;           If carry set A = character
; Destroys: A,H,L,F
;
MYOS_OSKEY:	PUSH    HL
            LD      HL,INKEY
            LD      A,(HL)
            LD      (HL),0
            POP     HL
            OR      A
            SCF
            RET     NZ		
            ;PUSH    DE
            CALL    GETKEY
            ;POP     DE
            RET     NC
            CP      ESC
            SCF
            RET     NZ                        
ESCSET: 		PUSH    HL
        		LD      HL,FLAGS
        		BIT     6,(HL)          ; ESC DISABLED?
        		JR      NZ,ESCDIS
        		SET     7,(HL)          ; SET ESCAPE FLAG
ESCDIS: 		POP     HL
        		RET	
ESCTEST:		IN A,(PORT_STM_IO)
		      	OR A
		      	RET Z
		      	CP 0x1B			; ESC	
	      		JR Z,ESCSET
	      		LD (INKEY),A
	       		RET

MYOS_TRAP:			CALL ESCTEST
MYOS_LTRAP:			LD A,(FLAGS)
			          OR A
		           	RET P
ABORT:       		LD HL,FLAGS 
		          	RES 7,(HL)
		          	JP ESCAPE          
;		          	
;OSINIT - Initialise RAM mapping etc.
;   Outputs: DE = initial value of HIMEM (top of RAM)
;            HL = initial value of PAGE (user program)
;            Z-flag reset indicates AUTO-RUN.
;  Destroys: A,D,E,H,L,F
;
MYOS_OSINIT: 		
            LD HL,RANDOM
            LD A,0x06
            LD (HL),A
            LD A,0xBB
            LD (HL),A
            XOR A
         		LD DE,0xFFFF		;DE = HIMEM
         		LD E,A             	;PAGE BOUNDARY
         		LD HL,@USER         		
         		RET	
;
;OSLINE - Read/edit a complete line, terminated by CR.
;   Inputs: HL addresses destination buffer.
;           (L=0)
;  Outputs: Buffer filled, terminated by CR.
;           A=0.
; Destroys: A,B,C,D,E,H,L,F
;
MYOS_OSLINE:	
             CALL GETKEY
			       JR Z,MYOS_OSLINE
			       OR A 
			       JR Z,MYOS_OSLINE 
			       LD (HL),A
			       INC HL
			       CP 0x0D
			       JR Z,OSL_L1 
			       CALL MYOS_OSWRCH
			       JR MYOS_OSLINE 
OSL_L1:			 CALL @CRLF
			       AND A
			       RET 
      
;
;OSCLI - Process an "operating system" command
;
MYOS_OSCLI: 
      CALL    SKIPSP
			CP      CR
			RET     Z
			CP      '|'
			RET     Z
			CP      '.'
			JP      Z,DOT           ;*.
			EX      DE,HL
			LD      HL,COMDS
OSCLI0:			LD      A,(DE)
			CALL    UPPRC
			CP      (HL)
			JR      Z,OSCLI2
			JR      C,HUH
OSCLI1:			BIT     7,(HL)
			INC     HL
			JR      Z,OSCLI1
			INC     HL
			INC     HL
			JR      OSCLI0
;
OSCLI2:			PUSH    DE
OSCLI3:			INC     DE
			INC     HL
			LD      A,(DE)
			CALL    UPPRC
			CP      '.'             ;ABBREVIATED?
			JR      Z,OSCLI4
			XOR     (HL)
			JR      Z,OSCLI3
			CP      80H
			JR      Z,OSCLI4
			POP     DE
			JR      OSCLI1
;
OSCLI4:			POP     AF
		        INC     DE
OSCLI5:			BIT     7,(HL)
			INC     HL
			JR      Z,OSCLI5
			LD      A,(HL)
			INC     HL
			LD      H,(HL)
			LD      L,A
			PUSH    HL
			EX      DE,HL
			JP      SKIPSP

HUH:    		LD      A,254
        		CALL    EXTERR
        		DEFM    'Bad command'
        		DEFB    0			

SKIPSP:			LD      A,(HL)
        		CP      ' '
        		RET     NZ
        		INC     HL
        		JR      SKIPSP	

UPPRC:  		AND     7FH
			CP      '`'
			RET     C
			AND     5FH             ;CONVERT TO UPPER CASE
			RET					

; OSCLI - *.
DOT:			RET

; OSCLI - *BYE
;
BYE:			JP 0

COMDS:  		DEFM    'BY'
			DEFB    'E'+80H
			DEFW    BYE
			DEFB	0FFH
  
MYOS_OSSAVE:
            ;bc = length of program
            ;hl = ACCS =FILENAME ENDS WITH 0X0D
            ;TOP = CONTAINS START OF BASIC PROGRAM LD HL,(TOP)
            ;OUT SAVE COMMAND (TWO BYTES)            
            ;OUT THE FILENAME 0X0D TERMINATED
            ;OUT THE LENGTH (TWO BYTES)            
            ;OUT THE BYTES
            ;COMMAND
            LD A,0xDD
            OUT (PORT_TAPE),A
            LD A,COMMD_SAVE
            OUT (PORT_TAPE),A
            ;FILENAME
OSSV_NXT:   LD A,(HL)
            OUT (PORT_TAPE),A
            INC HL
            CP 0x0D
            JR NZ,OSSV_NXT
            ;LENGTH
            LD A,C
            OUT (PORT_TAPE),A
            LD A,B
            OUT (PORT_TAPE),A
            ;BYTES
            LD HL,(PAGE)
OSSV_NXT2:  LD A,(HL)
            OUT (PORT_TAPE),A
            INC HL
            DEC BC
            LD A,B
            OR C
            JR NZ,OSSV_NXT2                        
            RET              
MYOS_OSLOAD:
            ;OUT LOAD COMMAND (TWO BYTES)
            ;OUT THE FILENAME 0X0D TERMINATED
            ;IN THE LENGTH (TWO BYTES)
            ;IN THE BYTES 
            LD A,0xDD
            OUT (PORT_TAPE),A
            LD A,COMMD_LOAD
            OUT (PORT_TAPE),A
            ;FILENAME
OSLD_NXT:   LD A,(HL)
            OUT (PORT_TAPE),A
            INC HL
            CP 0x0D
            JR NZ,OSLD_NXT
            ;LENGTH READ
            IN A,(PORT_TAPE)
            LD C,A
            IN A,(PORT_TAPE)
            LD B,A
            ;BYTES
            LD HL,(PAGE)                        
OSLD_NXT2:  IN A,(PORT_TAPE)
            LD (HL),A
            INC HL
            DEC BC
            LD A,B
            OR C
            JR NZ,OSLD_NXT2                        
            LD B,H
            LD C,L
            LD HL,TOP ;SAVE TOP OF BASIC 
            LD (HL),C
            INC HL
            LD (HL),B            
            SCF       ;SET C = NO ERROR            
            RET   
            
  
  
MYOS_OSBPUT:
MYOS_OSBGET: 
MYOS_OSSTAT: 
MYOS_OSSHUT: 
MYOS_OSOPEN: 
MYOS_OSCALL:   
MYOS_GETPTR: 
MYOS_PUTPTR: 
MYOS_GETEXT: 
MYOS_RESET: 
            RET
            
MYOS_CLG:
MYOS_COLOUR:
MYOS_DRAW:
MYOS_ENVEL:
MYOS_GCOL:
MYOS_MODE:
MYOS_MOVE:
MYOS_PLOT:
MYOS_SOUND:
MYOS_ADVAL:
MYOS_POINT:
MYOS_GETIMS:
MYOS_PUTIMS:
			XOR     A
			CALL    EXTERR
			DEFM    'Sorry'
			DEFB    0            
      
      

; Read a character - waits for input
; A: ASCII character
;
GETKEY:		  IN A,(PORT_STM_FLAGS)
			      AND 0x01
			      JR Z,GETKEY
GETKEY_NB:  IN A,(PORT_STM_IO)
            SCF
			      RET       
      

      
      
      
;=======================               
    
DELAY:    ;TODO CHANGE THIS TO BE ACCURATE  
      SLA C
      SLA C
      SLA C
      LD B,C
DEL0: DJNZ DEL0
      RET   
    
      
LCD_WR_DAT16:;TWO PARAMS
             ;D=VL E=VH
    LD A,E
    OUT (LCD_CS),A
     
LCD_WR_DAT:        
LCD_WR_BUS:  ;ONE PARAM VL
             ;PASS BY REGISTER D=VL 
             ;DESTROYS A            
    LD A,D  
    OUT (LCD_CS),A
    RET

LCD_WR_COM:;ONE PARAM VL
           ;PASS BY REGISTER D=VL
           ;DESTROYS A
    
    XOR A
    OUT (LCD_RS),A  ;RS LOW = COMMAND BYTE      
    CALL LCD_WR_BUS
    LD A,1
    OUT (LCD_RS),A  ;RS HIGH  = DATA BYTE
    RET
    
LCD_INIT: ;INITIALIZE THE SSD1963

    LD D,0xE2         ;PLL multiplier, set PLL clock to 120M
    CALL LCD_WR_COM   ;N=0x36 for 6.5M, 0x23 for 10M crystal
    LD D,0x1E
    CALL LCD_WR_DAT
    LD D,0x02
    CALL LCD_WR_DAT
    LD D,0x54
    CALL LCD_WR_DAT
    LD D,0xE0         ; PLL enable    
    CALL LCD_WR_COM
    LD D,0x01
    CALL LCD_WR_DAT
    LD BC,10        ;delay(10);
    CALL DELAY
    LD D,0xE0         ; PLL enable    
    CALL LCD_WR_COM   
    LD D,0x03
    CALL LCD_WR_DAT
    LD BC,10        ;delay(10);
    CALL DELAY    

    LD D,0x01         ; software reset  
    CALL LCD_WR_COM   
    LD BC,100       ;delay(100);
    CALL DELAY        
    LD D,0xE6         ;PLL setting for PCLK, depends on resolution  
    CALL LCD_WR_COM           
    LD D,0x03
    CALL LCD_WR_DAT   
    LD D,0xFF
    CALL LCD_WR_DAT       
    LD D,0xFF
    CALL LCD_WR_DAT   
    
    LD D,0xE6         ;LCD SPECIFICATION
    CALL LCD_WR_COM       
    LD D,0x20
    CALL LCD_WR_DAT   
    LD D,0x00
    CALL LCD_WR_DAT       
    LD D,0x03         ;Set HDP  799
    CALL LCD_WR_DAT   
    LD D,0x1F
    CALL LCD_WR_DAT   
    LD D,0x01         ;Set VDP  479
    CALL LCD_WR_DAT   
    LD D,0xDF
    CALL LCD_WR_DAT 
    LD D,0x00
    CALL LCD_WR_DAT     
        
        
    LD D,0xB4         ;HSYNC
    CALL LCD_WR_COM       
    LD D,0x03         ;Set HT 928
    CALL LCD_WR_DAT   
    LD D,0xA0
    CALL LCD_WR_DAT       
    LD D,0x00         ;Set HPS  46
    CALL LCD_WR_DAT   
    LD D,0x2E
    CALL LCD_WR_DAT   
    LD D,0x30         ;Set HPW  48
    CALL LCD_WR_DAT   
    LD D,0x00         ;Set LPS  15
    CALL LCD_WR_DAT 
    LD D,0x0F
    CALL LCD_WR_DAT   
    LD D,0x00
    CALL LCD_WR_DAT     
                                  
    LD D,0xB6         ;VSYNC
    CALL LCD_WR_COM       
    LD D,0x02         ;Set VT 525
    CALL LCD_WR_DAT   
    LD D,0x0D
    CALL LCD_WR_DAT       
    LD D,0x00         ;Set VPS  16
    CALL LCD_WR_DAT   
    LD D,0x10
    CALL LCD_WR_DAT   
    LD D,0x10         ;Set VPW  16
    CALL LCD_WR_DAT   
    LD D,0x00         ;Set FPS  8
    CALL LCD_WR_DAT 
    LD D,0x08
    CALL LCD_WR_DAT   
    
    LD D,0xBA         
    CALL LCD_WR_COM           
    LD D,0x0F
    CALL LCD_WR_DAT   ;GPIO[3:0] out 1
    
    LD D,0xB8         
    CALL LCD_WR_COM           
    LD D,0x07         ;GPIO3=input, GPIO[2:0]=output
    CALL LCD_WR_DAT         
    LD D,0x01         ;GPIO0 normal
    CALL LCD_WR_DAT             

    LD D,0x36         ;rotation
    CALL LCD_WR_COM           
    LD D,0x2A         
    CALL LCD_WR_DAT         

    LD D,0xF0         ;pixel data interface
    CALL LCD_WR_COM           
    LD D,0x03         ;CHANGE THIS FOR 8 BIT INTERFACE  
    CALL LCD_WR_DAT     

    LD BC,1       ;delay(1);
    CALL DELAY        

    LD D,0xB8         ;pixel data interface
    CALL LCD_WR_COM           
    LD D,0x0F         ;GPIO is controlled by host GPIO[3:0]=output   GPIO[0]=1  LCD ON  GPIO[0]=1  LCD OFF
    CALL LCD_WR_DAT   
    LD D,0x01         ;GPIO0 normal
    CALL LCD_WR_DAT   

    LD D,0xBA         
    CALL LCD_WR_COM           
    LD D,0x01         ;GPIO[0] out 1 --- LCD display on/off control PIN
    CALL LCD_WR_DAT   
    
    LD HL,0
    PUSH HL
    PUSH HL
    LD HL,799
    PUSH HL
    LD HL,479
    PUSH HL
    CALL LCD_SETXY
    LD HL,8       ;REMOVE 4 PARAMS FROM STACK
    ADD HL,SP
    LD SP,HL
  
    LD D,0x29         ;display on 
    CALL LCD_WR_COM       
    LD D,0xBE         ;set PWM for B/L
    CALL LCD_WR_COM                 
    LD D,0xF0         
    CALL LCD_WR_DAT   
    LD D,0x01         
    CALL LCD_WR_DAT   
    LD D,0xF0         
    CALL LCD_WR_DAT   
    LD D,0x00         
    CALL LCD_WR_DAT   
    LD D,0x00         
    CALL LCD_WR_DAT                   

    LD D,0xD0         
    CALL LCD_WR_COM                 
    LD D,0x0D         
    CALL LCD_WR_DAT         

    LD D,0x2C       
    CALL LCD_WR_COM 
    RET
      

LCD_SETXY:    ;SET WINDOW ON LCD TO FILL WITH BYTES
              ;4 PARAMS PASS BY STACK
              ;2 BYTES EACH PARAM TOTAL 8 BYTES
              ;X1,X2,Y1,Y2   X1,X2 SHOULD SWAP Y1,Y2 CAUSE OF THE LCD ORIENTATION
              ;WE SEND HERE
              ;X1 = IX+6_7  Y1=IX+4_5
              ;X2=  IX+2_3  Y2=IX+0_1
              
              ;WE SEND ON LCD
              ;Y1=IX+6_7 Y2=IX+2_3
              ;X1=IX+4_5 X2=IX+0_1
              ;HIGH BYTE FIRST SO +8 IS H AND +7 IS L
              ;SHOULD ADD SP,8 AFTER RET
              
    LD IX,2
    ADD IX,SP         
    LD D,0x2A         ;SEND IX PARAMS
    CALL LCD_WR_COM    
    LD D,(IX+7)
    CALL LCD_WR_DAT
    LD D,(IX+6)
    CALL LCD_WR_DAT
    LD D,(IX+3)
    CALL LCD_WR_DAT
    LD D,(IX+2)
    CALL LCD_WR_DAT       
    LD D,0x2B         ;SEND Y PARAMS
    CALL LCD_WR_COM   
    LD D,(IX+5)
    CALL LCD_WR_DAT
    LD D,(IX+4)
    CALL LCD_WR_DAT
    LD D,(IX+1)
    CALL LCD_WR_DAT
    LD D,(IX)
    CALL LCD_WR_DAT       
    LD D,0x2C         ;SEND DATA
    CALL LCD_WR_COM           
    RET
             

LCD_SETPIXEL: ;SEND A 16 BIT VALUE FOR COLOR
              ;COLOR VALUE ON HL  VH & VL
              ;DESTROYS D,A
    LD D,H        
    CALL LCD_WR_DAT 
    LD D,L
    CALL LCD_WR_DAT 
    RET

LCD_DRAWPIXEL: ; 2 PARAMS ON STACK TOTAL 4 BYTES
    LD IX,2     ;setXY(x, y, x, y);
    ADD IX,SP
    LD H,(IX+3)   ;X
    LD L,(IX+2)   ;X
    LD D,(IX+1) ;Y
    LD E,(IX) ;Y
    PUSH HL
    PUSH DE
    PUSH HL
    PUSH DE
    CALL LCD_SETXY
    LD HL,8       ;REMOVE PARAMS FROM STACK
    ADD HL,SP
    LD SP,HL
    LD HL,(FCOLOR)
    CALL LCD_SETPIXEL
    CALL LCD_CLRXY
    RET

LCD_CLRXY:  ;RESET LCD WINDOW TO FULL
     LD HL,0
     PUSH HL
     PUSH HL
     LD HL,LCD_WIDTH
     PUSH HL
     LD HL,LCD_HEIGHT
     PUSH HL
     CALL LCD_SETXY
     LD HL,8        ;REMOVE PARAMS FROM STACK
     ADD HL,SP
     LD SP,HL
     RET

LCD_DRAWHLINE: ;3 PARAMS 2-BYTES EACH TOTAL 6 BYTES
              ;X , Y , LENGTH
      LD IX,2
      ADD IX,SP
      LD H,(IX+5)   ;X  
      LD L,(IX+4)   ;X
      LD D,(IX+3)   ;Y
      LD E,(IX+2)   ;Y
      LD B,(IX+1)   ;LENGTH
      LD C,(IX)     ;LENGTH
      
      
      PUSH HL
      LD HL,0
      OR A           ;CLEAR CARRY
      SBC HL,BC      ;CHECK IF LENGTH<0
      JR C,POSH1
      XOR A          ;l=-l
			SUB C
			LD C,A
			SBC A,A
			SUB B
			LD B,A
			POP HL
      SBC HL,BC       ;x -= l;
      PUSH HL                    
POSH1: POP HL
			PUSH HL
      PUSH DE
      ADD HL,BC
      PUSH HL
      PUSH DE
      CALL LCD_SETXY   ;setXY(x, y, x+l, y);
      LD HL,8       ;REMOVE PARAMS FROM STACK
      ADD HL,SP
      LD SP,HL
      LD HL,(FCOLOR)    
NXTH1: CALL LCD_SETPIXEL
      DEC BC
      LD A,C
      OR B
      JR NZ, NXTH1     
      CALL LCD_CLRXY
      RET


LCD_DRAWVLINE: ;3 PARAMS 2-BYTES EACH TOTAL 6 BYTES
              ;X , Y , LENGTH
      LD IX,2
      ADD IX,SP
      LD D,(IX+5)   ;X  
      LD E,(IX+4)   ;X
      LD H,(IX+3)   ;Y
      LD L,(IX+2)   ;Y
      LD B,(IX+1)   ;LENGTH
      LD C,(IX)     ;LENGTH     
      PUSH HL
      LD HL,0
      OR A           ;CLEAR CARRY
      SBC HL,BC      ;CHECK IF LENGTH<0
      JR C,POSV1
      XOR A          ;l=-l
			SUB C
			LD C,A
			SBC A,A
			SUB B
			LD B,A
			POP HL
      SBC HL,BC       ;Y -= l;
      PUSH HL                   
POSV1: POP HL
			PUSH DE
      PUSH HL
      PUSH DE
      ADD HL,BC
      PUSH HL
      CALL LCD_SETXY   ;setXY(x, y, x, y+l);
      LD HL,8       ;REMOVE PARAMS FROM STACK
      ADD HL,SP
      LD SP,HL
      LD HL,(FCOLOR)    
NXTV1: CALL LCD_SETPIXEL
      DEC BC
      LD A,C
      OR B
      JR NZ, NXTV1     
      CALL LCD_CLRXY
      RET

LCD_DRAWLINE: ;4 PARAMS 2-BYTES EACH TOTAL 8 BYTES
              ;X1 , Y1 , X2, Y2
      LD IX,2
      ADD IX,SP
     ; LD D,(IX+7)   ;X1  
     ; LD E,(IX+6)   ;X1
     ; LD H,(IX+5)   ;Y1
    ;  LD L,(IX+4)   ;Y1
     ; LD D,(IX+3)   ;X2  
    ;  LD E,(IX+2)   ;X2
    ;  LD H,(IX+1)   ;Y2
    ;  LD L,(IX)     ;Y2
      
      LD H,(IX+5)   ;Y1
      LD L,(IX+4)   ;Y1
      LD D,(IX+1)   ;Y2
      LD E,(IX)     ;Y2
      OR A
      SBC HL,DE
      JR NZ,YNOTEQ
      ;CALL DRAWHLINE CAUSE Y1=Y2
      LD B,(IX+7)   ;X1
      LD C,(IX+6)   ;X1
      PUSH BC       ;X1 1ST PARAM ON STACK
      PUSH DE				;Y 2ND PARAM ON STACK
      LD H,(IX+3)   ;X2
      LD L,(IX+2)   ;X2       
      SBC HL,BC  	  ;X2-X1 = LENGTH OF HORIZ LINE
      PUSH HL       ;LENGTH 3RD PARAM ON STACK 
      CALL LCD_DRAWHLINE
      LD HL,6       ;REMOVE PARAMS FROM STACK
      ADD HL,SP
      LD SP,HL      
      RET
YNOTEQ:  
      LD H,(IX+7)   ;X1
      LD L,(IX+6)   ;X1
      LD D,(IX+3)   ;X2
      LD E,(IX+2)   ;X2 
      OR A
      SBC HL,DE
      JR NZ,XNOTEQ
      ;CALL DRAWVLINE CAUSE X1=X2
      PUSH DE       ;X2=X1 1ST PARAM ON STACK
      LD B,(IX+5)   ;Y1
      LD C,(IX+4)   ;Y1
      PUSH BC       ;Y1 2ND PARAM ON STACK
      LD H,(IX+1)   ;Y2
      LD L,(IX)   ;Y2       
      SBC HL,BC  	  ;Y2-Y1 = LENGTH OF VERT LINE
      PUSH HL       ;LENGTH 3RD PARAM ON STACK 
      CALL LCD_DRAWVLINE
      LD HL,6       ;REMOVE PARAMS FROM STACK
      ADD HL,SP
      LD SP,HL
      RET
XNOTEQ:
      ;LINE ALGORITHM
      JR C,X2GTX1
      ;HL=X1-X2
      XOR A		
      DEC A  ;XSTEP=-1
      JR DLNXT1
X2GTX1:      
     ; LD HL,DE      ;X2
      PUSH DE
      POP HL
      LD D,(IX+7)   ;X1
      LD E,(IX+6)   ;X1 
      OR A     
      SBC HL,DE     ;X2-X1 ON HL
      ;HL=X2-X1  HL=DX
      LD A,1        ;XSTEP=1
DLNXT1:
      LD B,0
      LD C,0
      PUSH BC       ;T
      PUSH HL       ;DX
      CP 1
      JR Z,DLXMINUS1
      LD B,0XFF
DLXMINUS1:LD C,A      
      PUSH BC       ;XSTEP
      LD H,(IX+5)   ;Y1
      LD L,(IX+4)   ;Y1
      LD D,(IX+1)   ;Y2
      LD E,(IX)     ;Y2      
      OR A
      SBC HL,DE
      JR C,Y2GTY1
      ;HL=Y1-Y2
      XOR A
      DEC A         ;YSTEP=-1
      JR DLNXT2
Y2GTY1:
      ;LD HL,DE      ;Y2
      PUSH DE
      POP HL
      LD D,(IX+5)   ;Y1
      LD E,(IX+4)   ;Y1  
      OR A
      SBC HL,DE  
      ;HL=Y2-Y1    HL=DY
      LD B,0
      LD A,1        ;YSTEP=1
DLNXT2:
      CP 1
      JR Z,DLYMINUS1
      LD B,0XFF
DLYMINUS1:
      LD C,A      
      PUSH HL       ;DY
      PUSH BC       ;YSTEP   
      LD IY,0
      ADD IY,SP
      ;IY+9= T HI
      ;IY+8= T LO
      ;IY+7= DX HI
      ;IY+6= DX LO
      ;IY+5= XSTEP
      ;IY+4= XSTEP
      ;IY+3= DY HI
      ;IY+2= DY LO
      ;IY+1= YSTEP
      ;IY= YSTEP
      
      ;DE = ROW
      ;LD D,(IX+7)   ;COL
      ;LD E,(IX+6)   ;COL
      LD D,(IY+7)    ;DX
      LD E,(IY+6)    ;DX
      OR A
      SBC HL,DE      ;DY-DX
      JP C,DXGTDY
      JP Z,DXGTDY
      ;DX<DY 
      ADD HL,DE      ;HL=DY
      LD B,H
      LD C,L
      SRL B
      RR C           ;(dy >> 1)
      LD HL,0
      SBC HL,BC      ;t = - (dy >> 1);
      LD (IY+9),H    ;SAVE T
      LD (IY+8),L    ;SAVE T
DLAGN1:
      LD D,(IX+5)   ;ROW
      LD E,(IX+4)   ;ROW=Y1
      LD H,(IX+7)   ;COL
      LD L,(IX+6)   ;COL=X1
      PUSH DE
      PUSH IX
      PUSH HL
      PUSH DE
      PUSH HL
      PUSH DE
      CALL LCD_SETXY
      LD HL,8       ;REMOVE PARAMS FROM STACK
      ADD HL,SP     ;
      LD SP,HL      
      LD HL,(FCOLOR)    
      CALL LCD_SETPIXEL
      POP IX
      POP DE
      LD H,(IX+1)   ;Y2
      LD L,(IX)     ;Y2 
      SBC HL,DE     ; ROW=Y2
      JP Z,DLEXIT
      LD B,(IY+1)   ;YSTEP HI
      LD C,(IY)     ;YSTEP LO
      EX DE,HL
      ADD HL,BC     ;row += ystep;
      LD (IX+5),H   ;SAVE ROW
      LD (IX+4),L   ;   
      ;EX DE,HL      ;DE=ROW
      LD D,(IY+9)   ; T
      LD E,(IY+8)   ; T      
      LD H,(IY+7)   ;DX
      LD L,(IY+6)   ;DX
      ADD HL,DE
      LD (IY+9),H   ;t += dx;
      LD (IY+8),L
      EX DE,HL
      LD HL,0
      SBC HL,DE
      JR NC,DLAGN1      
      LD B,(IY+5)   ;XSTEP HI
      LD C,(IY+4)   ;XSTEP LO
      LD H,(IX+7)   ;COL HI
      LD L,(IX+6)   ;COL LO
      ADD HL,BC     ;col += xstep;
      LD (IX+7),H   ;SAVE COL
      LD (IX+6),L   ;         
      							;t   -= dy;
      LD H,(IY+9)   ; T
      LD L,(IY+8)   ; T      
      LD B,(IY+3)   ;DY
      LD C,(IY+2)   ;DY
      SBC HL,BC
      LD (IY+9),H   ;t -= dY;
      LD (IY+8),L							
      JP DLAGN1
DXGTDY: 
      ADD HL,DE      ;HL=DY DE=DX
      LD B,D
      LD C,E
      SRL B
      RR C           ;(dX >> 1)
      LD HL,0
      SBC HL,BC      ;t = - (dy >> 1);
      LD (IY+9),H    ;SAVE T
      LD (IY+8),L    ;SAVE T
DLAGN2:
      LD D,(IX+5)   ;ROW
      LD E,(IX+4)   ;ROW=Y1
      LD H,(IX+7)   ;COL
      LD L,(IX+6)   ;COL=X1
      PUSH HL       ;SAVE COL
      PUSH IX
      PUSH HL
      PUSH DE
      PUSH HL
      PUSH DE
      CALL LCD_SETXY
      LD HL,8       ;REMOVE PARAMS FROM STACK
      ADD HL,SP     ;
      LD SP,HL      
      LD HL,(FCOLOR)    
      CALL LCD_SETPIXEL
      POP IX
      POP DE        ;RETRIEVE COL
      LD H,(IX+3)   ;X2
      LD L,(IX+2)   ;X2 
      SBC HL,DE     ; COL=X2?
      JR Z,DLEXIT
      EX DE,HL      ;HL=COL
      LD B,(IY+5)   ;XSTEP HI
      LD C,(IY+4)   ;XSTEP LO
      ADD HL,BC     ;col += xstep;
      LD (IX+7),H   ;SAVE COL
      LD (IX+6),L   ;   
      LD D,(IY+9)   ; T
      LD E,(IY+8)   ; T      
      LD H,(IY+3)   ;DY
      LD L,(IY+2)   ;DY
      ADD HL,DE
      LD (IY+9),H   ;t += dY;
      LD (IY+8),L
      EX DE,HL      ;T=DE
      LD HL,0
      SBC HL,DE
      JR NC,DLAGN2      
      LD B,(IY+1)   ;YSTEP HI
      LD C,(IY)     ;YSTEP LO
      LD H,(IX+5)   ;ROW HI
      LD L,(IX+4)   ;ROW LO
      ADD HL,BC     ;ROW += Ystep;
      LD (IX+5),H   ;SAVE COL
      LD (IX+4),L   ;         
      							;t   -= dX;
      LD H,(IY+9)   ; T
      LD L,(IY+8)   ; T      
      LD B,(IY+7)   ;DX
      LD C,(IY+6)   ;DX
      SBC HL,BC
      LD (IY+9),H   ;t -= dX;
      LD (IY+8),L							
      JP DLAGN2

DLEXIT:
      LD HL,10      ;REMOVE 10 IY PARAMS FROM STACK
      ADD HL,SP     ;
      LD SP,HL           
      RET          


LCD_PRINTCHAR:
      ;A THE CHAR TO BE PRINTED ON CURSORX AND CURSORY
      ;SETXY(CURSORX*FONT_WIDTH,CURSORY*FONT_HEIGHT,(CURSORX+1)*FONT_WIDTH,(CURSORY+1)*FONT_HEIGHT)
      ;FONT_PATTERN = B=FONT_ADDR  C=A FOR EACH FONT LINE JUST INCREASE B
      CP 0X08   ;BACKSPACE
      JP Z,PRCH_DOBCKSPC
      CP 0X0A   ;LINE FEED JUST IGNORE IT
      RET Z
      CP 0X0D   ;CHECK FOR ENTER
      JR NZ,PRCH_DOPRN
      LD HL,CURSORX
      JP PRCH_NEWLN 
PRCH_DOBCKSPC:
      LD HL,CURSORX      
      LD A,(HL)
      JR C,DOREALBCKSPC
      ;IF C IS NOT SET THEN GO LEFT
      CP 1      ;COMPARE WITH COLUMN 1 CAUSE OF THE PROMPT ON COLUMN 0
      RET Z
      DEC (HL)
      RET      
DOREALBCKSPC:
      CP 1      ;COMPARE WITH COLUMN 1 CAUSE OF THE PROMPT ON COLUMN 0
      JR Z,PRCH_DOBCKSPC2     ;IF 0 WE ARE ON THE 1ST COLUMN SO NOTHING TO DO JUST DELETE THE 8=BS FROM BUFFER
      DEC (HL)  ;GO 1 POSITION BACK
      PUSH HL
      LD A,32   ;PRINT SPACE
      CALL PRCH_DOPRN ;THIS FORWARDS THE CURSOR SO WE SHOULD GO BACK AGAIN
      POP HL
      DEC (HL)  ;GO 1 POSITION BACK
      OR A      
      ;NOW DELETE FROM THE BASIC BUFFER TOO
      ;BS =8 ALREADY PUT ON BUFFER SO WE SHOULD GO BACK 2 PLACES
PRCH_DOBCKSPC2:
      LD IX,2
      ADD IX,SP
      LD H,(IX+1);POSITION IN ACCS FOR THE NEW CHARACTER      
      LD L,(IX) ;POSITION IN ACCS FOR THE NEW CHARACTER  
      LD A,0    ;NOT XOR WE DONT WANT TO MESS WITH ZERO FLAG
      JR Z,PRCH_SKIP1  ;WE ARE ON COLUMN 1
      DEC HL     ;PREVIOUS POSITION DELETE BACKSPACE
      LD (HL),A  ;PUT 0 ON LAST POSITION
PRCH_SKIP1:      
      DEC HL     ;PREVIOUS POSITION DELETE PREVIOUS CHAR
      LD (HL),A  ;PUT 0 ON LAST POSITION      
      LD (IX+1),H ;PUT POSITION BACK ON STACK IT WILL POPED
      LD (IX),L
      RET
                  
PRCH_DOPRN:
      PUSH AF  ;SAVE CHAR TO STACK
      LD (LASTCHAR),A ;SAVE LAST PRINTED CHAR
      LD C,1
      LD A,(CURSORX)
PRCH_AGN1A:
      LD B,FONT_WIDTH
      LD D,0
      LD E,A
      LD HL,0
PRCH_AGN1:
      ADC HL,DE
      DJNZ PRCH_AGN1 ;HL=DE*B
      PUSH HL       ;1ST PARAM X1 & 3RD PARAM
      INC A
      DEC C
      JR Z,PRCH_AGN1A ;AGAIN FOR 3RD PARAM
      LD A,(CURSORY)
      LD C,1
PRCH_AGN2A:
      LD B,FONT_HEIGHT 
      LD D,0
      LD E,A
      LD HL,0
PRCH_AGN2:
      ADC HL,DE
      DJNZ PRCH_AGN2      
      DEC C
      JR NZ,PRCH_AGN2B
      POP DE        ;3RD PARAM X2
      PUSH HL       ;2ND PARAM Y1
      DEC DE        ;3RD PARAM - 1
      PUSH DE       ;3RD PARAM X2
      INC A
      JR PRCH_AGN2A
PRCH_AGN2B:    
      DEC HL        ;4TH PARAM -1  
      PUSH HL				;4TH PARAM Y2
      CALL LCD_SETXY
      LD HL,8
      ADD HL,SP
      LD SP,HL      ;SKIP 4 PARAMS 8 BYTES
      POP AF        ;CHAR TO PRINT FROM STACK
      LD HL,FONT_ADDR
      LD D,0
      LD E,A
      ADC HL,DE     ;THIS IS THE CHAR ADDRESS
      PUSH HL
      POP DE        ; CHAR ADDRESS ON DE
      LD C,FONT_HEIGHT   ; TOTAL FONT LINES
PRCH_AGN3:      
      LD A,(DE)           ;FONT 8BIT PATTERN FOR A LINE
      LD B,FONT_WIDTH-1      
PRCH_AGN4:      
      SLA A               ;CHECK BIT FOR 1=FCOLOR OR 0=BCOLOR
      JR C,FORECOLOR
      LD HL,(BCOLOR)
      JR PRCH_CONT
FORECOLOR:
      LD HL,(FCOLOR)      
PRCH_CONT:
      PUSH AF
      PUSH DE             ;TODO:PROBABLY NOT NEEDED HERE 
      CALL LCD_SETPIXEL
      POP DE
      POP AF      
      DJNZ PRCH_AGN4
      INC D             ;ADD 256 FOR NEXT CHAR PATTERN
      DEC C
      JR NZ,PRCH_AGN3
      ;FORWARD CURSOR
      LD HL,CURSORX
      LD A,(HL)
      INC A
      CP 80
      JR Z,PRCH_NEWLN  ;NEW LINE
      LD (HL),A
      RET
         
PRCH_NEWLN:
      XOR A  
      LD (HL),A   
      INC HL
      LD A,(HL)
      INC A       
      LD (HL),A
      ;CHECK FOR END OF SCREEN
             
          
      RET


LCD_TEST:  ; TEST LCD
    LD A,65
    CALL LCD_PRINTCHAR
    LD HL,CURSORX
    INC (HL)
    LD A,66
    CALL LCD_PRINTCHAR
     
    RET

    LD HL,10
    LD BC,210
    PUSH BC
    PUSH HL
    PUSH HL
    PUSH BC
    CALL LCD_DRAWLINE 
    LD HL,8       ;REMOVE PARAMS FROM STACK
    ADD HL,SP
    LD SP,HL    
   
  
  
  
  
    LD HL,10
    LD BC,210
    PUSH HL
    PUSH HL
    PUSH BC
    PUSH BC
    CALL LCD_DRAWLINE 
    LD HL,8       ;REMOVE PARAMS FROM STACK
    ADD HL,SP
    LD SP,HL    
    


    LD HL,10
    LD BC,210
    PUSH HL
    PUSH HL
    PUSH BC
    PUSH HL
    CALL LCD_DRAWLINE 
    LD HL,8       ;REMOVE PARAMS FROM STACK
    ADD HL,SP
    LD SP,HL
    LD HL,10
    LD BC,210
    PUSH HL
    PUSH HL
    PUSH HL
    PUSH BC
    CALL LCD_DRAWLINE 
    LD HL,8       ;REMOVE PARAMS FROM STACK
    ADD HL,SP
    LD SP,HL    
    RET



;
;OSLINE - Read/edit a complete line, terminated by CR.
;   Inputs: HL addresses destination buffer.
;           (L=0)
;  Outputs: Buffer filled, terminated by CR.
;           A=0.
; Destroys: A,B,C,D,E,H,L,F
;
MYOS_OSLINE2: ;LD      IX,200H
        LD      A,(FLAGS)
        BIT     3,A             ;EDIT MODE?
        JR      Z,OSLIN1
        RES     3,A
        LD      (FLAGS),A
        LD      HL,(EDPTR)
        CP      L
OSLIN1: LD      A,CR
        LD      (HL),A
        CALL    NZ,MYOS_OSWRCH
        LD      L,0
        LD      C,L             ;REPEAT FLAG
        JR      Z,OSWAIT        ;SUPPRESS UNWANTED SPACE
UPDATE: LD      B,0
UPD1:   LD      A,(HL)
        INC     B
        INC     HL
        CP      CR
        PUSH    AF
        PUSH    HL
        LD      E,A
        CALL    NZ,WRCH         ;FAST WRCH
        POP     HL
        POP     AF
        JR      NZ,UPD1
        LD      A,' '
        CALL    MYOS_OSWRCH
        LD      E,BS
UPD2:   PUSH    HL
        CALL    WRCH            ;FAST WRCH
        POP     HL
        DEC     HL
        DJNZ    UPD2
OSWAIT: LD      A,C
        DEC     B
        JR      Z,LIMIT
        OR      A               ;REPEAT COMMAND?
LIMIT:  CALL    Z,KEYGET        ;READ KEYBOARD
        LD      C,A             ;SAVE FOR REPEAT
        LD      DE,OSWAIT       ;RETURN ADDRESS
        PUSH    DE
        LD      A,(FLAGS)
        OR      A               ;TEST FOR ESCAPE
        LD      A,C
        JP      M,OSEXIT
        CP      11         ;CURSOR UP     (IX-11)
        JP      Z,LEFT
        CP      10         ;CURSOR DOWN   (IX-10)
        JP      Z,RIGHT
        LD      B,0
        CP      5          ;CLEAR LEFT    (IX-5)
        JR      Z,BACK
        CP      9          ;START OF LINE (IX-9)
        JR      Z,LEFT
        CP      7          ;CLEAR RIGHT   (IX-7)
        JR      Z,DELETE
        CP      8          ;END OF LINE   (IX-8)
        JP      Z,RIGHT
        LD      C,0             ;INHIBIT REPEAT
        CP      'P' AND 1FH
        JP      Z,TOGGLE
        CP      6          ;DELETE LEFT   (IX-6)
        JR      Z,BACK
        CP      4          ;CURSOR LEFT   (IX-4)
        JR      Z,LEFT
        CP      2          ;DELETE RIGHT  (IX-2)
        JR      Z,DELETE
        CP      1          ;INSERT SPACE  (IX-1)
        JR      Z,INSERT
        CP      3          ;CURSOR RIGHT  (IX-3)
        JR      Z,RIGHT
        CP      ' '             ;PRINTING CHARACTER
        JR      NC,SAVECH
        CP      CR              ;ENTER LINE
        RET     NZ
OSEXIT: LD      A,(HL)
        CALL    MYOS_OSWRCH          ;WRITE REST OF LINE
        INC     HL
        SUB     CR
        JR      NZ,OSEXIT
        POP     DE              ;DITCH RETURN ADDRESS
        CP      C
        JP      NZ,ABORT        ;ESCAPE
        LD      A,LF
        CALL    MYOS_OSWRCH
        LD      DE,(ERRLIN)
        XOR     A
        LD      L,A
        LD      (EDPTR),HL
        CP      D
        RET     NZ
        CP      E
        RET     NZ
        LD      DE,EDITST
        LD      B,4
CMPARE: LD      A,(DE)
        CP      (HL)
        LD      A,0
        RET     NZ
        INC     HL
        INC     DE
        LD      A,(HL)
        CP      '.'
        JR      Z,ABBR
        DJNZ    CMPARE
ABBR:   XOR     A
        LD      B,A
        LD      C,L
        LD      L,A
        LD      DE,LISTST
        EX      DE,HL
        LDIR
        LD      HL,FLAGS
        SET     3,(HL)
        RET
;
BACK:   SCF                     ;DELETE LEFT
LEFT:   INC     L               ;CURSOR LEFT
        DEC     L
        JR      Z,STOP
        LD      A,BS
        CALL    MYOS_OSWRCH
        DEC     L
        RET     NC
DELETE: LD      A,(HL)          ;DELETE RIGHT
        CP      CR
        JR      Z,STOP
        LD      D,H
        LD      E,L
DEL1:   INC     DE
        LD      A,(DE)
        DEC     DE
        LD      (DE),A
        INC     DE
        CP      CR
        JR      NZ,DEL1
DEL2:   POP     DE              ;DITCH
        JP      UPDATE
;
INSERT: LD      A,CR            ;INSERT SPACE
        CP      (HL)
        RET     Z
        LD      D,H
        LD      E,254
INS1:   INC     DE
        LD      (DE),A
        DEC     DE
        LD      A,E
        CP      L
        DEC     DE
        LD      A,(DE)
        JR      NZ,INS1
        LD      (HL),' '
        JR      DEL2
;
RIGHT:  LD      A,(HL)          ;CURSOR RIGHT
        CP      CR
        JR      Z,STOP
SAVECH: LD      D,(HL)          ;PRINTING CHARACTER
        LD      (HL),A
        INC     L
        JR      Z,WONTGO        ;LINE TOO LONG
        CALL    MYOS_OSWRCH
        LD      A,CR
        CP      D
        RET     NZ
        LD      (HL),A
        RET
;
WONTGO: DEC     L
        LD      (HL),CR
       ; LD      A,BEL
       ; CALL    MYOS_OSWRCH          ;BEEP!
STOP:   LD      C,0             ;STOP REPEAT
        RET
;
;
EDITST: DEFM    'EDIT'
LISTST: DEFM    'LIST'


    ALIGN 256
    @FONT_ADDR EQU $   ; ON A PAGE BOUNDARY


  ORG OSVARS  ; 
    FLAGS		 DEFS	1		; Flags: B7=ESC PRESSED, B6=ESC DISABLED
    FCOLOR   DEFW 0X5555 ;FOREGROUND COLOR
    BCOLOR   DEFW 0XAAAA ;BACKGROUND COLOR
    CURSORX  DEFB 0    ;0-79
    CURSORY  DEFB 0    ;0-47
    PRECSRX  DEFB 0    ;0-79
    PRECSRY  DEFB 0    ;0-47    
    LASTCHAR DEFB 0; 
    EDPTR    DEFW 0
    OPTVAL   DEFB 0
    INKEY    DEFB 0
    USER	 	 EQU $
    
    ENDMODULE